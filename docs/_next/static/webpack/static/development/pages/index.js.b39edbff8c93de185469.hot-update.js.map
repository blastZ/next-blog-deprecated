{"version":3,"file":"static/webpack/static/development/pages/index.js.b39edbff8c93de185469.hot-update.js","sources":["webpack:///./pages/posts/three-ways-to-remove-array-duplicates.mdx"],"sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\nimport Post from '../../components/Post';\nexport const frontMatter = {\n  slug: '/three-ways-to-remove-array-duplicates',\n  title: '数组去重的三种方式',\n  subTitle: '这是三种过滤数组中的重复元素，并返回只包含唯一变量的方法，我个人偏向于使用 filter，它在性能方面更占优势。',\n  tags: ['javascript'],\n  date: '2019/03/12',\n  published: false\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  frontMatter\n};\nconst MDXLayout = ({ children }) => <Post data={frontMatter}>{children}</Post>\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n    <h1>{`数组去重的三种方式`}</h1>\n    <p>{`这是数组去重的三种方式，我个人偏向于使用 `}<inlineCode parentName=\"p\">{`filter`}</inlineCode>{` 的方式，它在性能方面更占优。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const array = ['sheep', 1, 2, 'sheep', 'sheep', 3];\n\n// 1.Set\n[...new Set(array)];\n\n// 2.filter\narray.filter((o, index) => array.indexOf(o) === index);\n\n// 3.reduce\narray.reduce((result, current) => {\n  return result.indexOf(current) < 0 ? result.concat([current]) : result;\n}, []);\n\n// ['sheep', 1, 2, 3]\n`}</code></pre>\n    <h2>{`1.使用 Set`}</h2>\n    <p>{`先解释一下什么是 Set`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Set 是 ES6 新增的一种数据对象，只允许保存唯一变量，当你将它传入一个数组时，它会移除所有重复的变量。`}</p>\n    </blockquote>\n    <p>{`使用 Set 去除重复变量分为两步`}</p>\n    <ol>\n      <li parentName=\"ol\">{`首先创建一个 Set ，并传入一个数组，由于 Set 只允许唯一变量，所有的重复项都会被移除。`}</li>\n      <li parentName=\"ol\">{`现在所有重复性都被移除了，接着使用展开运算符 `}<inlineCode parentName=\"li\">{`...`}</inlineCode>{` 将 Set 转换会数组。`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const array = ['sheep', 1, 2, 'sheep', 'sheep', 3];\n\n// 第一步\nconst uniqueSet = new Set(array);\n// Set { 'sheep', 1, 2, 3 }\n\n// 第二步\nconst backToArray = [...uniqueSet];\n// ['sheep', 1, 2, 3]\n`}</code></pre>\n    <h2>{`2.使用 filter`}</h2>\n    <p>{`为了理解这种方式，先要了解这两个方法 `}<inlineCode parentName=\"p\">{`indexOf`}</inlineCode>{` 和 `}<inlineCode parentName=\"p\">{`filter`}</inlineCode>{`。`}</p>\n    <h3>{`indexOf`}</h3>\n    <p>{`indexOf 方法会根据所提供的元素返回数组中第一个被找到相同元素的下标`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const array = ['sheep', 1, 2, 'sheep', 'sheep', 3];\n\narray.indexOf('sheep'); // 0\narray.indexOf(1); // 1\narray.indexOf(2); // 2\narray.indexOf(3); // 5\n`}</code></pre>\n    <h3>{`filter`}</h3>\n    <p><inlineCode parentName=\"p\">{`filter`}</inlineCode>{` 方法会根据我们给定的条件返回一个新的数组。换句话说就是，如果元素通过\n条件返回 `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`，它就会被包含在过滤后的数组中，返回 `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` 就不会包含在新的\n数组中。`}</p>\n    <h3>{`过滤重复项`}</h3>\n    <p>{`我们可以通过 `}<inlineCode parentName=\"p\">{`filter`}</inlineCode>{` 方法检索重复项并剔除它们，只需要将过滤条件设置为：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const array = ['sheep', 1, 2, 'sheep', 'sheep', 3];\n\narray.filter((o, index) => array.indexOf(o) === index);\n// ['sheep', 1, 2, 3]\n`}</code></pre>\n    <h2>{`3.使用 reduce`}</h2>\n    <p><inlineCode parentName=\"p\">{`reduce`}</inlineCode>{` 方法会根据传入的 `}<inlineCode parentName=\"p\">{`reducer`}</inlineCode>{` 函数重组数组内的元素。`}</p>\n    <p>{`为了达到我们的目标，我们的 `}<inlineCode parentName=\"p\">{`reducer`}</inlineCode>{` 函数需要检查最终的数组中是否已经包含了当前元素，如果没有就加入，\n否则跳过当前元素。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const array = ['sheep', 1, 2, 'sheep', 'sheep', 3];\n\narray.reduce((result, current) => {\n  return result.indexOf(current) < 0 ? result.concat([current]) : result;\n}, []);\n// ['sheep', 1, 2, 3]\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAOA;AAAA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AADA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AADA;AAoBA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AADA;AAaA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AADA;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AADA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AADA;AAUA;AAEA;;;;A","sourceRoot":""}